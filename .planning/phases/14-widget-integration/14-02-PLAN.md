---
phase: 14-widget-integration
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - packages/widget/src/hooks/useOptionGroups.ts
  - packages/widget/src/hooks/usePriceFetch.ts
  - packages/widget/src/components/OptionGroupSelect.tsx
  - packages/widget/src/styles.ts
autonomous: true

must_haves:
  truths:
    - "useOptionGroups hook fetches option groups from the REST API on mount"
    - "OptionGroupSelect renders a native HTML select with choices and modifier labels"
    - "usePriceFetch accepts optionSelections and includes them in the price API call"
    - "Price modifier labels show +$15.00 for FIXED and +10% for PERCENTAGE modifiers"
    - "Option select styles match existing widget design (CSS variables, pm- prefix)"
  artifacts:
    - path: "packages/widget/src/hooks/useOptionGroups.ts"
      provides: "Hook to fetch option groups for a product"
      exports: ["useOptionGroups"]
    - path: "packages/widget/src/components/OptionGroupSelect.tsx"
      provides: "Accessible dropdown component for option group"
      exports: ["OptionGroupSelect"]
    - path: "packages/widget/src/hooks/usePriceFetch.ts"
      provides: "Extended price fetch with option selections"
      exports: ["usePriceFetch"]
    - path: "packages/widget/src/styles.ts"
      provides: "Extended CSS with option group styles"
      contains: "pm-option-group"
  key_links:
    - from: "packages/widget/src/hooks/useOptionGroups.ts"
      to: "/api/v1/products/:productId/options"
      via: "fetch call to options endpoint"
      pattern: "api/v1/products.*options"
    - from: "packages/widget/src/hooks/usePriceFetch.ts"
      to: "/api/v1/products/:productId/price"
      via: "options query parameter in fetch"
      pattern: "searchParams.*options"
    - from: "packages/widget/src/components/OptionGroupSelect.tsx"
      to: "packages/widget/src/types.ts"
      via: "OptionGroup and OptionChoice type imports"
      pattern: "import.*OptionGroup"
---

<objective>
Create the useOptionGroups hook, OptionGroupSelect component, extend usePriceFetch with option selections support, and add option group CSS styles.

Purpose: These are the core building blocks that Plan 03 will wire into the main widget. The hook fetches option data, the component renders accessible dropdowns with modifier labels, the price hook sends selections to the API, and styles ensure visual consistency.

Output: 1 new hook, 1 new component, 1 extended hook, extended CSS styles
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-widget-integration/14-01-SUMMARY.md

@packages/widget/src/types.ts
@packages/widget/src/hooks/usePriceFetch.ts
@packages/widget/src/styles.ts
@packages/widget/src/components/DimensionInput.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useOptionGroups hook and OptionGroupSelect component</name>
  <files>
    packages/widget/src/hooks/useOptionGroups.ts
    packages/widget/src/components/OptionGroupSelect.tsx
  </files>
  <action>
**useOptionGroups hook** (`packages/widget/src/hooks/useOptionGroups.ts`):

Create a hook that fetches option groups for a product on mount.

Interface:
```typescript
interface UseOptionGroupsOptions {
  apiUrl: string;
  apiKey: string;
  productId: string;
}

interface UseOptionGroupsReturn {
  groups: OptionGroup[];
  loading: boolean;
  error: string | null;
}
```

Implementation:
- `useState` for groups (OptionGroup[]), loading (boolean, initial true), error (string | null)
- `useEffect` fetches `${apiUrl}/api/v1/products/${productId}/options` with `X-API-Key` header
- On success: set groups from `data.optionGroups`, loading false
- On non-200 response: set error from response detail (RFC 7807) or generic message, loading false
- On 404 or network error: set groups to empty array (not an error — product just has no options), loading false
- Return { groups, loading, error }
- No debouncing needed — this is a one-time fetch on mount
- Use AbortController for cleanup on unmount (same pattern as usePriceFetch)
- Import OptionGroup and OptionGroupsApiResponse from ../types

**OptionGroupSelect component** (`packages/widget/src/components/OptionGroupSelect.tsx`):

Create an accessible dropdown component using native HTML `<select>`.

Props:
```typescript
interface OptionGroupSelectProps {
  group: OptionGroup;
  value: string | null;
  onChange: (choiceId: string | null) => void;
  currency: string;
}
```

Implementation:
- Render a `<div className="pm-option-group">`
- `<label htmlFor={`pm-option-${group.id}`} className="pm-option-label">` with group.name
- Append " *" (with space) to label text for REQUIRED groups
- `<select id={`pm-option-${group.id}`} className="pm-option-select">`
  - `value={value ?? ''}` for controlled component
  - `onChange={(e) => onChange(e.target.value || null)}` — empty string maps to null (no selection)
  - `required={group.requirement === 'REQUIRED'}`
  - `aria-required={group.requirement === 'REQUIRED'}`
- For OPTIONAL groups: first option is `<option value="">None</option>`
- For REQUIRED groups: first option is `<option value="" disabled>Select {group.name}...</option>`
- Map choices to `<option key={choice.id} value={choice.id}>` with text: `{choice.label} {formatModifier(choice, currency)}`

**formatModifier helper** (in same file, not exported):
- If modifierValue === 0, return empty string
- If FIXED: use `Intl.NumberFormat` with style 'currency', divide value by 100 (cents to dollars). Prepend "+" for positive values. Wrap in parentheses: `(+$15.00)`
- If PERCENTAGE: divide modifierValue by 100 to get percent (basis points to percent). Use `.toFixed(0)` for whole numbers. Prepend "+" for positive. Wrap in parentheses: `(+10%)`
- Use `navigator.language` for locale in Intl.NumberFormat
- Memoize the Intl.NumberFormat instance with useMemo keyed on currency
  </action>
  <verify>Run `cd packages/widget && npx tsc --noEmit` to confirm no TypeScript errors.</verify>
  <done>useOptionGroups hook fetches option groups on mount with proper loading/error states and cleanup. OptionGroupSelect renders accessible native select with modifier labels formatted correctly for both FIXED (currency) and PERCENTAGE (%) types.</done>
</task>

<task type="auto">
  <name>Task 2: Extend usePriceFetch with option selections and add option group CSS</name>
  <files>
    packages/widget/src/hooks/usePriceFetch.ts
    packages/widget/src/styles.ts
  </files>
  <action>
**Extend usePriceFetch** (`packages/widget/src/hooks/usePriceFetch.ts`):

Add option selections support to the existing price fetch hook.

Changes to `UsePriceFetchOptions`:
- Add `optionSelections?: OptionSelection[]` (default empty array)

Changes to `UsePriceFetchReturn`:
- Add `basePrice: number | null` — base price before option modifiers
- Add `optionModifiers: OptionModifierInfo[] | null` — modifier breakdown

Changes to the useEffect fetch logic:
- Import OptionSelection and OptionModifierInfo from ../types
- Accept `optionSelections` from options, default to `[]`
- When building the URL: if `optionSelections.length > 0`, add `options` query parameter as JSON string: `url.searchParams.set('options', JSON.stringify({ selections: optionSelections }))` — URLSearchParams.set auto-encodes
- Add `optionSelections` to the useEffect dependency array (use `JSON.stringify(optionSelections)` as dependency to avoid reference equality issues — create a `const optionsKey = JSON.stringify(optionSelections)` outside the effect and depend on optionsKey)
- IMPORTANT: Do NOT debounce option selections. Only width/height are debounced. Option changes should trigger an immediate price refetch. The effect already triggers on dependency changes, so adding optionsKey to deps is sufficient.
- On successful response: extract `basePrice` and `optionModifiers` from response if present (optional fields), set state
- Add state for basePrice and optionModifiers (both nullable)
- Return basePrice and optionModifiers alongside existing fields

**Add option group CSS** (`packages/widget/src/styles.ts`):

Add styles for option group selects to the `widgetStyles` string. Place after the quantity selector styles and before the add-to-cart button styles. Follow existing conventions:
- All classes use `pm-` prefix
- Colors use CSS custom properties
- Font sizes use `var(--pm-font-size)`

Add:
```css
/* Option group selector */
.pm-option-group {
  margin-bottom: 16px;
}

.pm-option-label {
  display: block;
  font-weight: 600;
  margin-bottom: 6px;
  font-size: var(--pm-font-size);
  color: var(--pm-text-color);
}

.pm-option-select {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--pm-border-color);
  border-radius: var(--pm-border-radius);
  font-size: var(--pm-font-size);
  font-family: inherit;
  color: var(--pm-text-color);
  background: white;
  cursor: pointer;
  appearance: none;
  -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23637381' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
  padding-right: 32px;
}

.pm-option-select:focus {
  outline: none;
  border-color: var(--pm-primary-color);
  box-shadow: 0 0 0 1px var(--pm-primary-color);
}
```

The `appearance: none` + custom dropdown arrow SVG follows the same visual pattern as the dimension inputs (clean, consistent with the rest of the widget). The SVG arrow is a simple triangle matching the existing `#637381` secondary color.
  </action>
  <verify>Run `cd packages/widget && npx tsc --noEmit` to confirm no TypeScript errors.</verify>
  <done>usePriceFetch accepts optionSelections parameter, includes them as JSON in API query string, returns basePrice and optionModifiers from response. CSS styles for option groups match existing widget design using CSS custom properties.</done>
</task>

</tasks>

<verification>
1. Widget TypeScript compiles: `cd packages/widget && npx tsc --noEmit`
2. useOptionGroups hook exists with proper types and fetch logic
3. OptionGroupSelect renders native select with modifier labels
4. usePriceFetch includes options in API call and returns breakdown data
5. CSS styles use pm- prefix and CSS custom properties consistently
</verification>

<success_criteria>
- useOptionGroups fetches from `/api/v1/products/:productId/options` and returns typed groups
- OptionGroupSelect uses native HTML `<select>` with accessibility attributes (label, required, aria-required)
- Price modifier labels show "+$15.00" for FIXED and "+10%" for PERCENTAGE modifiers correctly
- usePriceFetch includes option selections in API call only when selections exist (backward compatible)
- Option select CSS matches existing widget visual style
</success_criteria>

<output>
After completion, create `.planning/phases/14-widget-integration/14-02-SUMMARY.md`
</output>
