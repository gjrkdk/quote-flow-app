---
phase: 14-widget-integration
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - packages/widget/src/PriceMatrixWidget.tsx
  - packages/widget/src/hooks/useDraftOrder.ts
autonomous: true

must_haves:
  truths:
    - "Widget renders dropdown for each option group assigned to the product"
    - "Widget updates price live as customer selects options"
    - "Widget shows price modifier next to each option value"
    - "Widget works correctly with products that have no option groups (backward compatible)"
    - "Widget provides accessible keyboard navigation for option dropdowns"
  artifacts:
    - path: "packages/widget/src/PriceMatrixWidget.tsx"
      provides: "Main widget component with option group integration"
      exports: ["PriceMatrixWidget"]
    - path: "packages/widget/src/hooks/useDraftOrder.ts"
      provides: "Draft order hook extended with option selections"
      exports: ["useDraftOrder"]
  key_links:
    - from: "packages/widget/src/PriceMatrixWidget.tsx"
      to: "packages/widget/src/hooks/useOptionGroups.ts"
      via: "useOptionGroups hook call"
      pattern: "useOptionGroups"
    - from: "packages/widget/src/PriceMatrixWidget.tsx"
      to: "packages/widget/src/components/OptionGroupSelect.tsx"
      via: "OptionGroupSelect component rendering"
      pattern: "OptionGroupSelect"
    - from: "packages/widget/src/PriceMatrixWidget.tsx"
      to: "packages/widget/src/hooks/usePriceFetch.ts"
      via: "optionSelections passed to usePriceFetch"
      pattern: "optionSelections"
    - from: "packages/widget/src/hooks/useDraftOrder.ts"
      to: "/api/v1/draft-orders"
      via: "options array in POST body"
      pattern: "options.*optionGroupId"
---

<objective>
Wire option groups into the main widget component and extend the draft order hook. This completes the full integration: option group dropdowns render, live price updates include options, and draft orders contain option selections.

Purpose: This is the final assembly plan. Plans 01 and 02 created the building blocks (API endpoint, types, hooks, components, styles). This plan wires them into the main widget and handles the add-to-cart flow with options.

Output: Complete widget with option group support, buildable and backward compatible
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-widget-integration/14-01-SUMMARY.md
@.planning/phases/14-widget-integration/14-02-SUMMARY.md

@packages/widget/src/PriceMatrixWidget.tsx
@packages/widget/src/hooks/useDraftOrder.ts
@packages/widget/src/hooks/usePriceFetch.ts
@packages/widget/src/hooks/useOptionGroups.ts
@packages/widget/src/components/OptionGroupSelect.tsx
@packages/widget/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useDraftOrder with option selections</name>
  <files>packages/widget/src/hooks/useDraftOrder.ts</files>
  <action>
Extend the useDraftOrder hook to include option selections in the Draft Order creation POST request.

Changes to `CreateDraftOrderParams`:
- Add `options?: OptionSelection[]` (optional, for backward compatibility)

Changes to `createDraftOrder` implementation:
- Import `OptionSelection` from `../types`
- When building the POST body: if `params.options` exists and has length > 0, include `options: params.options` in the JSON body. Otherwise omit the options field entirely (backward compatible — the API treats missing options as "no options")
- The API expects options as: `Array<{ optionGroupId: string; choiceId: string }>` directly in the POST body (NOT wrapped in `{ selections: [...] }` — that's the GET query param format)

No changes to the return type needed — DraftOrderApiResponse already has optional basePrice and optionModifiers from Plan 01's type extension.
  </action>
  <verify>Run `cd packages/widget && npx tsc --noEmit` to confirm no TypeScript errors.</verify>
  <done>useDraftOrder includes option selections in POST body when provided, omits them when not provided (backward compatible).</done>
</task>

<task type="auto">
  <name>Task 2: Integrate option groups into PriceMatrixWidget and verify build</name>
  <files>packages/widget/src/PriceMatrixWidget.tsx</files>
  <action>
Wire all option group building blocks into the main widget component.

**New imports:**
- `useOptionGroups` from `./hooks/useOptionGroups`
- `OptionGroupSelect` from `./components/OptionGroupSelect`
- `OptionSelection` from `./types`

**New state:**
- `const [selections, setSelections] = useState<OptionSelection[]>([])` for tracking option selections

**useOptionGroups hook call:**
- Call `useOptionGroups({ apiUrl, apiKey, productId })` to fetch option groups on mount
- Destructure: `{ groups, loading: groupsLoading }`

**Initialize default selections:**
- After groups load, pre-select default choices for REQUIRED groups using a useEffect:
  ```
  useEffect(() => {
    if (groups.length === 0) return;
    const defaults: OptionSelection[] = [];
    for (const group of groups) {
      if (group.requirement === 'REQUIRED') {
        const defaultChoice = group.choices.find(c => c.isDefault);
        if (defaultChoice) {
          defaults.push({ optionGroupId: group.id, choiceId: defaultChoice.id });
        }
      }
    }
    if (defaults.length > 0) {
      setSelections(defaults);
    }
  }, [groups]);
  ```

**Pass selections to usePriceFetch:**
- Extend the usePriceFetch call to include `optionSelections: selections`:
  `usePriceFetch({ apiUrl, apiKey, productId, optionSelections: selections }, quantity)`

**Selection update handler:**
- Create `updateSelection` callback:
  ```
  const updateSelection = useCallback((groupId: string, choiceId: string | null) => {
    setSelections(prev => {
      const filtered = prev.filter(s => s.optionGroupId !== groupId);
      if (choiceId) {
        return [...filtered, { optionGroupId: groupId, choiceId }];
      }
      return filtered; // null = cleared (OPTIONAL group)
    });
  }, []);
  ```

**Render option group selects:**
- Between the Height DimensionInput and the QuantitySelector, conditionally render option groups:
  ```jsx
  {groups.length > 0 && groups.map((group) => (
    <OptionGroupSelect
      key={group.id}
      group={group}
      value={selections.find(s => s.optionGroupId === group.id)?.choiceId ?? null}
      onChange={(choiceId) => updateSelection(group.id, choiceId)}
      currency={currency ?? 'USD'}
    />
  ))}
  ```
- This renders nothing when groups is empty (backward compatible with no option groups)
- Pass currency from usePriceFetch (default to 'USD' if not yet loaded)

**Pass selections to handleAddToCart:**
- In the handleAddToCart callback, include options in the createDraftOrder call:
  ```
  const result = await createDraftOrder({
    productId,
    width: widthNum,
    height: heightNum,
    quantity,
    options: selections.length > 0 ? selections : undefined,
  });
  ```

**Validation for required option groups:**
- Before the add-to-cart button disabled check, add validation that all REQUIRED groups have a selection:
  ```
  const hasAllRequiredOptions = groups
    .filter(g => g.requirement === 'REQUIRED')
    .every(g => selections.some(s => s.optionGroupId === g.id));
  ```
- Include in `isAddToCartDisabled`: add `|| (groups.length > 0 && !hasAllRequiredOptions)`

**After all code changes, build the widget:**
- Run `cd packages/widget && npm run build` to verify the widget builds with ESM + UMD outputs and TypeScript declarations
- This confirms all new code integrates correctly with Vite library mode bundling
  </action>
  <verify>
1. Run `cd packages/widget && npx tsc --noEmit` to confirm TypeScript compiles
2. Run `cd packages/widget && npm run build` to confirm Vite builds ESM + UMD outputs
3. Verify dist/ contains updated files: `ls packages/widget/dist/`
  </verify>
  <done>PriceMatrixWidget renders option group dropdowns when groups exist, updates price live on selection change, passes options to draft order creation, validates required selections, maintains backward compatibility with no groups, and widget builds successfully.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd packages/widget && npx tsc --noEmit`
2. Widget builds: `cd packages/widget && npm run build`
3. Build output exists: `ls packages/widget/dist/quote-flow.es.js packages/widget/dist/quote-flow.umd.js packages/widget/dist/index.d.ts`
4. App TypeScript compiles: `npx tsc --noEmit` from project root
5. Backward compatibility: Widget code renders no option UI when groups array is empty
</verification>

<success_criteria>
- Widget renders dropdown for each option group assigned to the product (SC 1)
- Widget updates price live as customer selects options (SC 2)
- Widget shows price modifier next to each option value e.g. "+$15.00", "+20%" (SC 3)
- Widget works correctly with products that have no option groups (SC 4)
- Widget provides accessible keyboard navigation via native HTML select elements (SC 5)
- Widget builds with ESM + UMD outputs and TypeScript declarations
</success_criteria>

<output>
After completion, create `.planning/phases/14-widget-integration/14-03-SUMMARY.md`
</output>
